import { BinaryParser } from './parser';
import { APP_CONFIG, EXPERIMENTAL_CONFIG, CSL_STOCK_WOT_THRESHOLD_MAP } from '@/config/constants';
import { VEMap } from '@/lib/types';

export class BinaryPatcher extends BinaryParser {
    constructor(buffer: ArrayBuffer) {
        super(buffer.slice(0)); // Clone buffer to avoid mutating original source if needed
    }

    public setUint8(offset: number, value: number): void {
        // Validate bounds omitted for brevity, view will throw
        this.view.setUint8(offset, value);
    }

    public setUint16(offset: number, value: number): void {
        this.view.setUint16(offset, value, false); // Big Endian
    }

    public disableMapCorrection(): void {
        // Set k_rf_cfg (0xE5E4) to 0x02
        this.setUint8(APP_CONFIG.MSS54HP.ADDRESS_MAP_CONFIG, 0x02);
        // Set Temp Limit to 100C (disabled adaptation behavior)
        // Formula: val = temp + 48 -> 100 + 48 = 148
        this.setUint8(APP_CONFIG.MSS54HP.ADDRESS_TEMP_LIMIT, 148);
    }

    public enableMapCorrection(): void {
        // Restore to Stock/Initial
        // User Request: MAF = 0x12
        this.setUint8(APP_CONFIG.MSS54HP.ADDRESS_MAP_CONFIG, 0x12);

        // User Request: LTFT = 69 (deg C)
        // Formula: val = temp + 48. 69 + 48 = 117 (0x75)
        this.setUint8(APP_CONFIG.MSS54HP.ADDRESS_TEMP_LIMIT, 117);
    }

    public setTempThreshold(tempCelsius: number): void {
        // Value = Temp + 48
        const val = tempCelsius + 48;
        this.setUint8(APP_CONFIG.MSS54HP.ADDRESS_TEMP_LIMIT, val);
    }

    public setVETable(map: VEMap): void {
        const config = APP_CONFIG.MSS54HP.VE_TABLE;

        // We only write DATA, not axes (usually axes are fixed/read-only or we don't need to change them)
        // Writing 24 rows x 20 cols
        for (let row = 0; row < config.SIZE_Y; row++) {
            for (let col = 0; col < config.SIZE_X; col++) {
                const offset = config.ADDRESS_DATA + (row * config.SIZE_X + col) * 2;
                const value = map.data[row][col];
                // User specified Z-axis is z/1000, so we write back value * 1000
                this.setUint16(offset, Math.round(value * 1000)); // Ensure integer
            }
        }
    }

    public getPatchedBuffer(): ArrayBuffer {
        return this.buffer;
    }

    /**
     * [EXPERIMENTAL] Writes the autogenerated Warmup Map to binary.
     * Assumes 20x24 Dimension (Standard VE).
     */
    public setWarmupTable(map: VEMap): void {
        const addr = EXPERIMENTAL_CONFIG.ADDRESS_WARMUP_MAP;
        if (addr === 0x0000) return;

        // Iterate Rows (Load) -> Cols (RPM)
        for (let r = 0; r < map.data.length; r++) {
            for (let c = 0; c < map.data[0].length; c++) {
                const val = map.data[r][c];
                // Scaling: Likely uint16 * 1000 like main table?
                // Screenshot suggests 0.xx range. Main table is 0.xx range.
                // Assuming Main Table scaling holds for now (uint16 / 1000).
                // TODO: Verify scaling if different.
                this.setUint16(addr + (r * map.data[0].length + c) * 2, Math.round(val * 1000));
            }
        }
    }

    /**
     * [EXPERIMENTAL] Writes the autogenerated WOT Map to binary.
     * Dimensions: 3 Rows x 18 Cols.
     * Address: 0xB5A.
     * Scaling: x/128 (uint8).
     */
    public setWOTMap(map: number[][]): void {
        const addr = EXPERIMENTAL_CONFIG.ADDRESS_WOT_MAP;
        if (addr === 0x0000) return;

        let offset = 0;
        for (let r = 0; r < map.length; r++) {
            for (let c = 0; c < map[0].length; c++) {
                const val = map[r][c];
                // Scaling: val = raw / 128  => raw = val * 128
                const raw = Math.round(val * 128);
                // Clamp to uint8 limit
                const clamped = Math.min(255, Math.max(0, raw));

                this.setUint8(addr + offset, clamped);
                offset++;
            }
        }
    }

    public setWOTThreshold(disable: boolean): void {
        const addr = EXPERIMENTAL_CONFIG.ADDRESS_WOT_THRESHOLD_MAP;
        if (addr === 0x0000) return;

        // 4x4 Map = 16 values. Uint16.
        // Scaling x/10.
        // Disable -> Set to >100% (e.g. 102.3% = 1023) to prevent WOT activation.
        // Enable -> Restore Stock

        const mapData = disable
            ? Array(4).fill(Array(4).fill(102.3)) // > 100%
            : CSL_STOCK_WOT_THRESHOLD_MAP;

        let offset = 0;
        for (let r = 0; r < 4; r++) {
            for (let c = 0; c < 4; c++) {
                const val = mapData[r][c];
                const raw = Math.round(val * 10);
                this.setUint16(addr + offset, raw);
                offset += 2; // 2 bytes per value
            }
        }
    }
}
